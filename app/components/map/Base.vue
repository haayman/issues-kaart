<template>
  <LMap
    v-if="layer"
    v-bind="$attrs"
    v-model:bounds="latLngBounds"
    :use-global-leaflet="true"
    :options="{ editable: true, ...($attrs.options || {}) }"
    @ready="mapLoaded"
  >
    <template v-if="ready">
      <slot :map="mapPromise" />
    </template>
    <template v-for="(layerConfig, index) in layer.layer" :key="index">
      <component :is="getLayerComponent(layerConfig.type)" v-bind="{ ...layerConfig, 'z-index': index }" />
    </template>
  </LMap>
</template>
<script setup lang="ts">
import { isBoundsTuples, type IBoundsTuples } from "~/types/IBounds";
import { LMap, LTileLayer, LWmsTileLayer } from "@vue-leaflet/vue-leaflet";

import type { LatLngBounds, Map } from "leaflet";
import type { ConfigLayer } from "~/types/LayerConfig";
import LWMTSTileLayer from "./LWMTSTileLayer.vue";

const mapPromise = deferred<Map>();
const mapObject = shallowRef<Map | null>(null);
useMap().provideMap(mapPromise.promise);

const bounds = defineModel<IBoundsTuples>("bounds", {
  required: true,
});

const latLngBounds = computed({
  get: () => {
    return bounds.value as LatLngBounds | IBoundsTuples;
  },
  set: (value) => {
    bounds.value = parseBounds(value);
  },
});

const props = defineProps<{
  baseLayer?: ConfigLayer;
}>();

const ready = ref(false);
const config = getConfig();

const defaultBaseLayer = computed(() => {
  return config.baseLayers.find((layer: ConfigLayer) => layer.visible);
});

const layer = computed(() => {
  const layer = props.baseLayer || defaultBaseLayer.value;

  if (!layer) {
    const error = new Error("No baselayer available in the config");
    throw error;
  }

  return layer;
});

function getLayerComponent(type: string) {
  if (type === "tile") {
    return LTileLayer;
  } else if (type === "wms") {
    return LWmsTileLayer;
  } else if (type === "wmts") {
    return LWMTSTileLayer;
  }
  throw new Error(`Invalid layer type ${type}`);
}

const resizeObserver = new ResizeObserver(() => {
  if (mapObject.value) {
    mapObject.value.invalidateSize();
  }
});

onUnmounted(() => {
  resizeObserver?.disconnect();
});

function mapLoaded(map: Map) {
  mapPromise.resolve(map);
  ready.value = true;
  mapObject.value = map;
  resizeObserver.observe(map.getContainer());
}

watch(
  [bounds, mapObject],
  () => {
    if (mapObject.value && bounds.value) {
      if (!isBoundsTuples(bounds.value)) {
        const [[south, west], [north, east]] = parseBounds(bounds.value);
        bounds.value = [
          [south, west],
          [north, east],
        ];
      }
      mapObject.value.fitBounds(bounds.value);
    }
  },
  { immediate: true, deep: true }
);

defineExpose({
  mapPromise,
  mapObject,
});
</script>
